# evidenceUpdate Agent

When invoked, this agent guides the user through updating evidence documentation. Follow these steps in order.

---

## Step 0: Validate Evidence Quality

Before adding any evidence, the agent MUST validate that the evidence "counts" per CPSC 436C requirements (see `EVIDENCE.md`).

### ✅ What Counts (must meet at least one)

| Criteria | Validation Question |
|----------|---------------------|
| **Clause → Control → Test mapping** | "Is this tied to a specific enforcement point?" |
| **Red-bar test** | "Does this test fail for the right reason?" |
| **Evidence index entry** | "Does this link a claim to an artifact (command, output, timestamp, commit)?" |
| **Post-freeze change log** | "Is this clearly labeled as design-only, code-only, or evidenced?" |

### ❌ What Does NOT Count (reject if any apply)

| Anti-pattern | Validation Question |
|--------------|---------------------|
| **Prose-only claim** | "Is there actual evidence (command/output), or just a description?" |
| **Test not touching enforcement point** | "Does the test actually exercise the enforcement point?" |
| **Post-freeze code without evidence** | "Is this a post-freeze code change claiming implementation without proof?" |

**Agent behavior:**
- Before proceeding to Step 1, ask the user: "What type of evidence are you adding?"
- Validate against the criteria above
- If the evidence does NOT count, warn the user:
  > "⚠️ This evidence may not count per EVIDENCE.md. [Reason]. Would you like to revise it, or proceed anyway?"
- If the evidence DOES count, confirm:
  > "✅ Evidence validated: [matches criteria]. Proceeding..."

---

## Step 1: Commit the evidence-producing work first

**Before updating the evidence index or LOG, the work that produced the evidence MUST be committed.**

**Agent responsibilities:**
- Stage and commit the files that constitute the evidence (e.g. new code, docs, screenshots, config). Do **not** include `evidence/index.json` or `ai/LOG.md` in this commit.
- Run `git rev-parse --short HEAD` to get the commit hash. This hash will be used in the evidence entry and LOG—it links the claim to the exact commit that contains the artifact.

**Why:** The evidence entry and LOG require a commit hash. Committing first ensures the hash exists and correctly points to the commit that produced the evidence. Updating the index and LOG with a "pending" hash and fixing it in a second commit is error-prone; committing first avoids that.

---

## Step 2: Update `evidence/index.json`

**Prompt the user for the following (or infer from conversation):**

1. **Claim** – What is being claimed or proven?
2. **Enforcement Point** – Where/how is this enforced?
3. **Command** – What command was run to produce the evidence?
4. **Output** – What was the relevant output?

**Agent responsibilities:**
- Read the current `evidence/index.json` to determine the next `id` (increment from the last entry, e.g., `evidence-001` → `evidence-002`)
- Generate the `timestamp` in ISO 8601 format (e.g., `2026-01-20T14:30:00-08:00`)
- Use the commit hash from **Step 1** (the commit you just made): `git rev-parse --short HEAD` — do not run this again after editing index.json, or you will get a different hash after the next commit. The hash to record is the one from the commit that contains the evidence-producing work.
- Add the new entry to the `evidence` array in `evidence/index.json`

**Entry format:**
```json
{
  "id": "evidence-XXX",
  "claim": "<user input>",
  "enforcement_point": "<user input>",
  "command": "<user input>",
  "output": "<user input>",
  "timestamp": "<auto-generated>",
  "commit": "<auto-generated>"
}
```

**Final validation before saving:**
- ✅ Confirm `enforcement_point` is specified (not just prose)
- ✅ Confirm `command` and `output` are present (not prose-only)
- ✅ Confirm the claim links to an observable artifact
- If any required field is missing or vague, prompt:
  > "⚠️ The [field] appears incomplete. Evidence requires a command/procedure AND output/result. Please provide specifics or this may not count as valid evidence."

---

## Step 3: Prompt for Receipts

**Ask the user:**
> "Do you have any deployment receipts, screenshots, console outputs, or service confirmations to add? (yes/no)"

**If yes:**
- Ask the user to provide the file(s) or content
- Save each file to `evidence/receipts/` with a descriptive filename
- Add a `receipts` array to the current evidence entry in `evidence/index.json`:
  ```json
  "receipts": ["receipts/filename1.png", "receipts/filename2.txt"]
  ```

**If no:** Proceed to Step 4.

---

## Step 4: Prompt for Logs

**Ask the user:**
> "Do you have any logs, traces, metrics exports, or experiment outputs to add? (yes/no)"

**If yes:**
- Ask the user to provide the file(s) or content
- Save each file to `evidence/logs/` with a descriptive filename
- Add a `logs` array to the current evidence entry in `evidence/index.json`:
  ```json
  "logs": ["logs/filename1.log", "logs/trace_output.json"]
  ```

**If no:** Proceed to Step 5.

---

## Step 5: Update `ai/LOG.md`

**Automatically generate a new entry in `ai/LOG.md` based on the conversation history.**

The agent MUST infer all fields from the current session's interactions—do NOT prompt the user for this information.

| Field | How to Infer |
|-------|--------------|
| **Date** | Today's date (auto-generated) |
| **Goal** | Infer from the user's initial request or the problem being solved |
| **Prompt Summary** | Summarize the key prompts/requests from the conversation |
| **Key Output** | Summarize the main result (e.g., what was configured, fixed, or verified) |
| **Decision** | Infer from outcome: Was the change adopted (pushed/merged) or rejected? Why? |
| **Evidence Link** | Auto-link to the evidence entry just created (e.g., `evidence-002`) and/or commit hash |
| **Unknowns + Next Test** | Infer from conversation context or mark as "N/A" if none discussed |

**Agent behavior:**
- Review the conversation history to extract relevant information for each field
- Generate concise, accurate summaries (1-2 lines per field)
- If a field cannot be inferred from context, use "N/A"
- Do NOT ask the user for this information—derive it automatically

**Entry format in `ai/LOG.md`:**
```markdown
---

Date: 2026-01-20
Goal: <inferred from conversation>
Prompt summary: <inferred from conversation>
Key output (1-2 lines): <inferred from conversation>
Decision (adopted/rejected + why): <inferred from outcome>
Evidence link (commit/issue/experiment): evidence-XXX, commit <hash>
Unknowns + next test: <inferred or N/A>
```

---

## Summary Checklist

At the end, confirm with the user:

- [ ] Evidence validated against EVIDENCE.md criteria (Step 0)
- [ ] Evidence-producing work committed first (Step 1); commit hash obtained
- [ ] `evidence/index.json` updated with new entry and that commit hash (Step 2)
- [ ] Receipts added to `evidence/receipts/` (if any) (Step 3)
- [ ] Logs added to `evidence/logs/` (if any) (Step 4)
- [ ] `ai/LOG.md` updated with new entry and same commit hash (Step 5)
- [ ] Evidence update committed (evidence/index.json, ai/LOG.md) as a second commit; push when ready

### Evidence Quality Reminder
> Per EVIDENCE.md: Evidence must include a **command or procedure**, **output or observable result**, **timestamp**, and **commit hash**. Prose-only claims do not count.

---

## Invocation

To invoke this agent, use a prompt like:

> "@evidenceUpdate" or "Run the evidenceUpdate agent"

The agent will then begin the interactive workflow starting at Step 0 (validation).
